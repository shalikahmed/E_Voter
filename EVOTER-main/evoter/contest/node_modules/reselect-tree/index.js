(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("reselect-tree", [], factory);
	else if(typeof exports === 'object')
		exports["reselect-tree"] = factory();
	else
		root["reselect-tree"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["createNestedSelector"] = createNestedSelector;
/* harmony export (immutable) */ __webpack_exports__["createLeaf"] = createLeaf;
/* harmony export (immutable) */ __webpack_exports__["createSelectorTree"] = createSelectorTree;
const debugModule = __webpack_require__( 1);
const debug = debugModule("reselect-tree");

const { createSelector, createStructuredSelector } = __webpack_require__(2);
const jsonpointer = __webpack_require__(3);

/**
 * Create a single memoized selector for a collection of named sub-selectors.
 * Behaves like `createStructuredSelector` but also allows direct invocation
 * of child selectors.
 *
 * For example:
 *
 *   const shop = createNestedSelector({
 *     items: (state) => state.items,
 *     promos: (state) => state.promos
 *   });
 *
 * Results in three selectors:
 *
 *   shop(state) ==> { items: state.items, promos: state.items }
 *   shop.items(state) => state.items
 *   shop.promos(state) => state.promos
 *
 * Override `rootSelector` to change behavior of top-level (i.e. `shop(state)`
 * in example.)
 *
 * @param {Object} selectors - object description of selector funcs
 * @param {Selector} rootSelector - specify root selector instead of aggregation
 * @return Selector
 */
function createNestedSelector (selectors, rootSelector = null) {
  let selector;

  if (!rootSelector) {
    // unspecified means default to structured aggregation
    selector = createStructuredSelector(selectors);

  } else if (!(rootSelector instanceof Object) || !rootSelector.resultFunc) {
    // rootSelector isn't already a selector, or it's not an object...
    // forward to `createSelector()`
    selector = createSelector(rootSelector);
  } else {
    // otherwise, just use as is
    selector = rootSelector;
  }

  // add properties for child selectors
  Object.keys(selectors).forEach( (prop) => {
    selector[prop] = selectors[prop];
  });

  return selector;
}

class Leaf {
  constructor(deps, selector) {
    this.deps = deps;
    this.selector = selector;
  }

  contextualize(resolve, pointer) {
    let resolved = this.deps
      .map( (dep) => {
        if (typeof dep == 'string') {
          if (dep == "") {
            dep = "/";
          }

          const abspath = _resolvePointer(pointer, "..", dep);
          debug("pointer %o", pointer);
          debug("abspath %o", abspath);

          return (...args) => {
            debug("args: %o", args);
            let selector = resolve(abspath);
            debug("resolved selector: %o", selector);
            if(!selector) {
              throw new Error(
                `Error: Cannot resolve dep ${dep} on ${pointer}`
              );
            }
            let result = selector.apply(selector, args);
            debug("result: %o", result);
            return result;
          }
        }

        return dep;
      });

    return createSelector(resolved, this.selector);
  }
}

function createLeaf(deps, selector) {
  return new Leaf(deps, selector);
}

class Tree {
  setRoot(root) {
    this.root = root;
  }

  resolve(abspath) {
    var resolved;
    try {
      let parsed = jsonpointer.parse(abspath);

      let cur = this.root;
      for (let step of parsed) {
        cur = cur[step];
      }

      return cur;

    } catch (e) {
      debug("failed, root: %O", this.root);
      throw e;
    }

    return resolved;
  }
}

function createSelectorTree (root) {
  let tree = new Tree();

  let selector = _createNode(root, tree.resolve.bind(tree), "");

  tree.setRoot(selector);

  return selector;
}

/**
 * Recursively create a selector node in the tree, applying context to nodes
 * as needed.
 */
function _createNode(node, resolve, pointer = "") {
  //based on type of node, operate differently
  if (node instanceof Function) {
    // plain functions are converted to contextualized Leaf nodes
    return createLeaf([state => state], node).contextualize(resolve, pointer);

  } else if (node instanceof Leaf) {
    // explicit leaf nodes just need context resolution for relative deps
    return node.contextualize(resolve, pointer);

  } else if (node instanceof Object) {
    // otherwise, node is an object, so recurse
    const recurse =
      (key, child) => _createNode(child, resolve, `${pointer}/${key}`);

    let selectors = Object.assign({},
      ...Object.entries(node)
        .map( ([key, child]) => ({ [key]: recurse(key, child) }) )
    );

    // special-case `_` child nodes override root selector
    const rootSelector = selectors._ || null;

    return createNestedSelector(selectors, rootSelector);

  } else {
    // other types are not allowed
    throw new Error(
      `Invalid node in selector tree at ${pointer}. ` +
      `Must be function, leaf, or object. Received: ${node}`
    );
  }
}

/**
 * Behaves like path.posix.resolve(), ensuring the returned string is a
 * /-separated string with no ".." or ".".
 *
 * Later absolute entries in `paths` (i.e., items that start with `/`)
 * supercede previous entries.
 */
function _resolvePointer(...paths) {
  return paths
    // reduce to /-separated string, ignoring anything before the last-
    // specified absolute path (e.g. ["/a", "/b", "./c"] becomes "/b/./c")
    .reduce((joined, next) => {
      // next child is absolute; discard previous
      if (next.startsWith("/")) {
        return next;
      }

      return `${joined}/${next}`;
    }, "")

    // now, remove .. and .
    .split("/")
    .reduce((resolved, next) => {
      switch (next) {
        case "..":
          return resolved.slice(0, -1);
        case ".":
          return resolved;
        default:
          return resolved.concat(next);
      }
    }, [])
    .join("/");
}


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("reselect");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("json-pointer");

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbIndlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2svYm9vdHN0cmFwIDdmYTY0MTYwMWViNGU1NGZlMzYwIiwiL2hvbWUvc25pZmZub3kvdHJ1ZmZsZS9yZXNlbGVjdC10cmVlL2xpYi9pbmRleC5qcyIsImV4dGVybmFsIFwiZGVidWdcIiIsImV4dGVybmFsIFwicmVzZWxlY3RcIiIsImV4dGVybmFsIFwianNvbi1wb2ludGVyXCIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJyZXNlbGVjdC10cmVlXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInJlc2VsZWN0LXRyZWVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicmVzZWxlY3QtdHJlZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQ